/**
 * Standalone signaling server for the Nextcloud Spreed app.
 * Copyright (C) 2019 struktur AG
 *
 * @author Joachim Bauch <bauch@struktur.de>
 *
 * @license GNU AGPL version 3 or any later version
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package signaling

import (
	"context"
	"encoding/json"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/strukturag/nextcloud-spreed-signaling/api"
	"github.com/strukturag/nextcloud-spreed-signaling/talk"
)

func TestVirtualSession(t *testing.T) {
	t.Parallel()
	require := require.New(t)
	assert := assert.New(t)
	hub, _, _, server := CreateHubForTest(t)

	roomId := "the-room-id"
	emptyProperties := json.RawMessage("{}")
	backend := talk.NewCompatBackend(nil)
	room, err := hub.CreateRoom(roomId, emptyProperties, backend)
	require.NoError(err)
	defer room.Close()

	clientInternal := NewTestClient(t, server, hub)
	defer clientInternal.CloseWithBye()
	require.NoError(clientInternal.SendHelloInternal())

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	if hello, ok := clientInternal.RunUntilHello(ctx); ok {
		assert.Empty(hello.Hello.UserId)
		assert.NotEmpty(hello.Hello.SessionId)
		assert.NotEmpty(hello.Hello.ResumeId)
	}
	client, hello := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId)

	roomMsg := MustSucceed2(t, client.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	// Ignore "join" events.
	assert.NoError(client.DrainMessages(ctx))

	internalSessionId := api.PublicSessionId("session1")
	userId := "user1"
	msgAdd := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "addsession",
			AddSession: &api.AddSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				UserId: userId,
				Flags:  FLAG_MUTED_SPEAKING,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgAdd))

	msg1 := MustSucceed1(t, client.RunUntilMessage, ctx)
	// The public session id will be generated by the server, so don't check for it.
	require.True(client.checkMessageJoinedSession(msg1, "", userId))
	sessionId := msg1.Event.Join[0].SessionId
	session := hub.GetSessionByPublicId(sessionId)
	if assert.NotNil(session, "Could not get virtual session %s", sessionId) {
		assert.Equal(api.HelloClientTypeVirtual, session.ClientType())
		sid := session.(*VirtualSession).SessionId()
		assert.Equal(internalSessionId, sid)
	}

	// Also a participants update event will be triggered for the virtual user.
	msg2 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg2); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		if assert.Len(updateMsg.Users, 1) {
			assert.EqualValues(sessionId, updateMsg.Users[0]["sessionId"])
			assert.Equal(true, updateMsg.Users[0]["virtual"])
			assert.EqualValues((FlagInCall | FlagWithPhone), updateMsg.Users[0]["inCall"])
		}
	}

	msg3 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg3); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.EqualValues(FLAG_MUTED_SPEAKING, flagsMsg.Flags)
	}

	newFlags := uint32(FLAG_TALKING)
	msgFlags := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "updatesession",
			UpdateSession: &api.UpdateSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				Flags: &newFlags,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgFlags))

	msg4 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg4); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.Equal(newFlags, flagsMsg.Flags)
	}

	// A new client will receive the initial flags of the virtual session.
	client2, _ := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId+"2")
	roomMsg = MustSucceed2(t, client2.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	gotFlags := false
	var receivedMessages []*api.ServerMessage
	for !gotFlags {
		messages, err := client2.GetPendingMessages(ctx)
		if err != nil {
			assert.NoError(err)
			if errors.Is(err, context.DeadlineExceeded) || errors.Is(err, context.Canceled) {
				break
			}
		}

		receivedMessages = append(receivedMessages, messages...)
		for _, msg := range messages {
			if msg.Type != "event" || msg.Event.Target != "participants" || msg.Event.Type != "flags" {
				continue
			}

			if assert.Equal(roomId, msg.Event.Flags.RoomId) &&
				assert.Equal(sessionId, msg.Event.Flags.SessionId) &&
				assert.Equal(newFlags, msg.Event.Flags.Flags) {
				gotFlags = true
				break
			}
		}
	}
	assert.True(gotFlags, "Didn't receive initial flags in %+v", receivedMessages)

	// Ignore "join" messages from second client
	assert.NoError(client.DrainMessages(ctx))

	// When sending to a virtual session, the message is sent to the actual
	// client and contains a "Recipient" block with the internal session id.
	recipient := api.MessageClientMessageRecipient{
		Type:      "session",
		SessionId: sessionId,
	}

	data := "from-client-to-virtual"
	require.NoError(client.SendMessage(recipient, data))

	msg2 = MustSucceed1(t, clientInternal.RunUntilMessage, ctx)
	require.True(checkMessageType(t, msg2, "message"))
	require.True(checkMessageSender(t, hub, msg2.Message.Sender, "session", hello.Hello))

	if assert.NotNil(msg2.Message.Recipient) {
		assert.Equal("session", msg2.Message.Recipient.Type)
		assert.Equal(internalSessionId, msg2.Message.Recipient.SessionId)
	}

	var payload string
	if err := json.Unmarshal(msg2.Message.Data, &payload); assert.NoError(err) {
		assert.Equal(data, payload)
	}

	msgRemove := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "removesession",
			RemoveSession: &api.RemoveSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgRemove))

	if msg5, ok := client.RunUntilMessage(ctx); ok {
		client.checkMessageRoomLeaveSession(msg5, sessionId)
	}
}

func TestVirtualSessionActorInformation(t *testing.T) {
	t.Parallel()
	require := require.New(t)
	assert := assert.New(t)
	hub, _, _, server := CreateHubForTest(t)

	roomId := "the-room-id"
	emptyProperties := json.RawMessage("{}")
	backend := talk.NewCompatBackend(nil)
	room, err := hub.CreateRoom(roomId, emptyProperties, backend)
	require.NoError(err)
	defer room.Close()

	clientInternal := NewTestClient(t, server, hub)
	defer clientInternal.CloseWithBye()
	require.NoError(clientInternal.SendHelloInternal())

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	if hello, ok := clientInternal.RunUntilHello(ctx); ok {
		assert.Empty(hello.Hello.UserId)
		assert.NotEmpty(hello.Hello.SessionId)
		assert.NotEmpty(hello.Hello.ResumeId)
	}
	client, hello := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId)

	roomMsg := MustSucceed2(t, client.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	// Ignore "join" events.
	assert.NoError(client.DrainMessages(ctx))

	internalSessionId := api.PublicSessionId("session1")
	userId := "user1"
	msgAdd := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "addsession",
			AddSession: &api.AddSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				UserId: userId,
				Flags:  FLAG_MUTED_SPEAKING,
				Options: &api.AddSessionOptions{
					ActorId:   "actor-id",
					ActorType: "actor-type",
				},
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgAdd))

	msg1 := MustSucceed1(t, client.RunUntilMessage, ctx)
	// The public session id will be generated by the server, so don't check for it.
	require.True(client.checkMessageJoinedSession(msg1, "", userId))
	sessionId := msg1.Event.Join[0].SessionId
	session := hub.GetSessionByPublicId(sessionId)
	if assert.NotNil(session, "Could not get virtual session %s", sessionId) {
		assert.Equal(api.HelloClientTypeVirtual, session.ClientType())
		sid := session.(*VirtualSession).SessionId()
		assert.Equal(internalSessionId, sid)
	}

	// Also a participants update event will be triggered for the virtual user.
	msg2 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg2); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		if assert.Len(updateMsg.Users, 1) {
			assert.EqualValues(sessionId, updateMsg.Users[0]["sessionId"])
			assert.Equal(true, updateMsg.Users[0]["virtual"])
			assert.EqualValues((FlagInCall | FlagWithPhone), updateMsg.Users[0]["inCall"])
		}
	}

	msg3 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg3); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.EqualValues(FLAG_MUTED_SPEAKING, flagsMsg.Flags)
	}

	newFlags := uint32(FLAG_TALKING)
	msgFlags := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "updatesession",
			UpdateSession: &api.UpdateSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				Flags: &newFlags,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgFlags))

	msg4 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg4); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.Equal(newFlags, flagsMsg.Flags)
	}

	// A new client will receive the initial flags of the virtual session.
	client2, _ := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId+"2")
	roomMsg = MustSucceed2(t, client2.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	gotFlags := false
	var receivedMessages []*api.ServerMessage
	for !gotFlags {
		messages, err := client2.GetPendingMessages(ctx)
		if err != nil {
			assert.NoError(err)
			if errors.Is(err, context.DeadlineExceeded) || errors.Is(err, context.Canceled) {
				break
			}
		}

		receivedMessages = append(receivedMessages, messages...)
		for _, msg := range messages {
			if msg.Type != "event" || msg.Event.Target != "participants" || msg.Event.Type != "flags" {
				continue
			}

			if assert.Equal(roomId, msg.Event.Flags.RoomId) &&
				assert.Equal(sessionId, msg.Event.Flags.SessionId) &&
				assert.Equal(newFlags, msg.Event.Flags.Flags) {
				gotFlags = true
				break
			}
		}
	}
	assert.True(gotFlags, "Didn't receive initial flags in %+v", receivedMessages)

	// Ignore "join" messages from second client
	assert.NoError(client.DrainMessages(ctx))

	// When sending to a virtual session, the message is sent to the actual
	// client and contains a "Recipient" block with the internal session id.
	recipient := api.MessageClientMessageRecipient{
		Type:      "session",
		SessionId: sessionId,
	}

	data := "from-client-to-virtual"
	require.NoError(client.SendMessage(recipient, data))

	msg2 = MustSucceed1(t, clientInternal.RunUntilMessage, ctx)
	require.True(checkMessageType(t, msg2, "message"))
	require.True(checkMessageSender(t, hub, msg2.Message.Sender, "session", hello.Hello))

	if assert.NotNil(msg2.Message.Recipient) {
		assert.Equal("session", msg2.Message.Recipient.Type)
		assert.Equal(internalSessionId, msg2.Message.Recipient.SessionId)
	}

	var payload string
	if err := json.Unmarshal(msg2.Message.Data, &payload); assert.NoError(err) {
		assert.Equal(data, payload)
	}

	msgRemove := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "removesession",
			RemoveSession: &api.RemoveSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgRemove))

	if msg5, ok := client.RunUntilMessage(ctx); ok {
		client.checkMessageRoomLeaveSession(msg5, sessionId)
	}
}

func checkHasEntryWithInCall(t *testing.T, message *api.RoomEventServerMessage, sessionId api.PublicSessionId, entryType string, inCall int) bool {
	assert := assert.New(t)
	found := false
	for _, entry := range message.Users {
		if sid, ok := api.GetStringMapString[api.PublicSessionId](entry, "sessionId"); ok && sid == sessionId {
			if value, found := api.GetStringMapEntry[bool](entry, entryType); !assert.True(found, "entry %s not found or invalid in %+v", entryType, entry) ||
				!assert.True(value, "entry %s invalid in %+v", entryType, entry) {
				return false
			}

			if value, found := api.GetStringMapEntry[float64](entry, "inCall"); !assert.True(found, "inCall not found or invalid in %+v", entry) ||
				!assert.InDelta(value, inCall, 0.0001, "invalid inCall") {
				return false
			}
			found = true
			break
		}
	}

	return assert.True(found, "no user with session id %s found, got %+v", sessionId, message)
}

func TestVirtualSessionCustomInCall(t *testing.T) {
	t.Parallel()
	require := require.New(t)
	assert := assert.New(t)
	hub, _, _, server := CreateHubForTest(t)

	roomId := "the-room-id"
	emptyProperties := json.RawMessage("{}")
	backend := talk.NewCompatBackend(nil)
	room, err := hub.CreateRoom(roomId, emptyProperties, backend)
	require.NoError(err)
	defer room.Close()

	clientInternal := NewTestClient(t, server, hub)
	defer clientInternal.CloseWithBye()
	features := []string{
		api.ClientFeatureInternalInCall,
	}
	require.NoError(clientInternal.SendHelloInternalWithFeatures(features))

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	client, hello := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId)

	helloInternal, ok := clientInternal.RunUntilHello(ctx)
	if ok {
		assert.Empty(helloInternal.Hello.UserId)
		assert.NotEmpty(helloInternal.Hello.SessionId)
		assert.NotEmpty(helloInternal.Hello.ResumeId)
	}
	roomMsg := MustSucceed3(t, clientInternal.JoinRoomWithRoomSession, ctx, roomId, "")
	require.Equal(roomId, roomMsg.Room.RoomId)

	roomMsg = MustSucceed2(t, client.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	// In some cases, the participants update event is triggered a bit after the joined
	// event. If this happens, the "client" will also receive an additional update
	// event after the joined of the internal client.
	var expectUpdate bool
	if _, additional, ok := clientInternal.RunUntilJoinedAndReturn(ctx, helloInternal.Hello, hello.Hello); ok {
		if len(additional) == 0 {
			if msg, ok := clientInternal.RunUntilMessage(ctx); ok {
				additional = append(additional, msg)
			}
			expectUpdate = true
		}
		if assert.Len(additional, 1) && assert.Equal("event", additional[0].Type) {
			assert.Equal("participants", additional[0].Event.Target)
			assert.Equal("update", additional[0].Event.Type)
			assert.EqualValues(helloInternal.Hello.SessionId, additional[0].Event.Update.Users[0]["sessionId"])
			assert.EqualValues(0, additional[0].Event.Update.Users[0]["inCall"])
		}
	}
	if _, additional, ok := client.RunUntilJoinedAndReturn(ctx, helloInternal.Hello, hello.Hello); ok {
		if expectUpdate {
			if len(additional) == 0 {
				if msg, ok := client.RunUntilMessage(ctx); ok {
					additional = append(additional, msg)
				}
			}

			if assert.Len(additional, 1) && assert.Equal("event", additional[0].Type) {
				assert.Equal("participants", additional[0].Event.Target)
				assert.Equal("update", additional[0].Event.Type)
				assert.EqualValues(helloInternal.Hello.SessionId, additional[0].Event.Update.Users[0]["sessionId"])
				assert.EqualValues(0, additional[0].Event.Update.Users[0]["inCall"])
			}
		}
	}

	internalSessionId := api.PublicSessionId("session1")
	userId := "user1"
	msgAdd := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "addsession",
			AddSession: &api.AddSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				UserId: userId,
				Flags:  FLAG_MUTED_SPEAKING,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgAdd))

	msg1 := MustSucceed1(t, client.RunUntilMessage, ctx)
	// The public session id will be generated by the server, so don't check for it.
	require.True(client.checkMessageJoinedSession(msg1, "", userId))
	sessionId := msg1.Event.Join[0].SessionId
	session := hub.GetSessionByPublicId(sessionId)
	if assert.NotNil(session) {
		assert.Equal(api.HelloClientTypeVirtual, session.ClientType())
		sid := session.(*VirtualSession).SessionId()
		assert.Equal(internalSessionId, sid)
	}

	// Also a participants update event will be triggered for the virtual user.
	msg2 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg2); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		assert.Len(updateMsg.Users, 2)

		checkHasEntryWithInCall(t, updateMsg, sessionId, "virtual", 0)
		checkHasEntryWithInCall(t, updateMsg, helloInternal.Hello.SessionId, "internal", 0)
	}

	msg3 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg3); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.EqualValues(FLAG_MUTED_SPEAKING, flagsMsg.Flags)
	}

	// The internal session can change its "inCall" flags
	msgInCall := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "incall",
			InCall: &api.InCallInternalClientMessage{
				InCall: FlagInCall | FlagWithAudio,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgInCall))

	msg4 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg4); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		assert.Len(updateMsg.Users, 2)
		checkHasEntryWithInCall(t, updateMsg, sessionId, "virtual", 0)
		checkHasEntryWithInCall(t, updateMsg, helloInternal.Hello.SessionId, "internal", FlagInCall|FlagWithAudio)
	}

	// The internal session can change the "inCall" flags of a virtual session
	newInCall := FlagInCall | FlagWithPhone
	msgInCall2 := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "updatesession",
			UpdateSession: &api.UpdateSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				InCall: &newInCall,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgInCall2))

	msg5 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg5); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		assert.Len(updateMsg.Users, 2)
		checkHasEntryWithInCall(t, updateMsg, sessionId, "virtual", newInCall)
		checkHasEntryWithInCall(t, updateMsg, helloInternal.Hello.SessionId, "internal", FlagInCall|FlagWithAudio)
	}
}

func TestVirtualSessionCleanup(t *testing.T) {
	t.Parallel()
	require := require.New(t)
	assert := assert.New(t)
	hub, _, _, server := CreateHubForTest(t)

	roomId := "the-room-id"
	emptyProperties := json.RawMessage("{}")
	backend := talk.NewCompatBackend(nil)
	room, err := hub.CreateRoom(roomId, emptyProperties, backend)
	require.NoError(err)
	defer room.Close()

	clientInternal := NewTestClient(t, server, hub)
	defer clientInternal.CloseWithBye()
	require.NoError(clientInternal.SendHelloInternal())

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	if hello, ok := clientInternal.RunUntilHello(ctx); ok {
		assert.Empty(hello.Hello.UserId)
		assert.NotEmpty(hello.Hello.SessionId)
		assert.NotEmpty(hello.Hello.ResumeId)
	}
	client, _ := NewTestClientWithHello(ctx, t, server, hub, testDefaultUserId)

	roomMsg := MustSucceed2(t, client.JoinRoom, ctx, roomId)
	require.Equal(roomId, roomMsg.Room.RoomId)

	// Ignore "join" events.
	assert.NoError(client.DrainMessages(ctx))

	internalSessionId := api.PublicSessionId("session1")
	userId := "user1"
	msgAdd := &api.ClientMessage{
		Type: "internal",
		Internal: &api.InternalClientMessage{
			Type: "addsession",
			AddSession: &api.AddSessionInternalClientMessage{
				CommonSessionInternalClientMessage: api.CommonSessionInternalClientMessage{
					SessionId: internalSessionId,
					RoomId:    roomId,
				},
				UserId: userId,
				Flags:  FLAG_MUTED_SPEAKING,
			},
		},
	}
	require.NoError(clientInternal.WriteJSON(msgAdd))

	msg1 := MustSucceed1(t, client.RunUntilMessage, ctx)
	// The public session id will be generated by the server, so don't check for it.
	require.True(client.checkMessageJoinedSession(msg1, "", userId))
	sessionId := msg1.Event.Join[0].SessionId
	session := hub.GetSessionByPublicId(sessionId)
	if assert.NotNil(session) {
		assert.Equal(api.HelloClientTypeVirtual, session.ClientType())
		sid := session.(*VirtualSession).SessionId()
		assert.Equal(internalSessionId, sid)
	}

	// Also a participants update event will be triggered for the virtual user.
	msg2 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if updateMsg, ok := checkMessageParticipantsInCall(t, msg2); ok {
		assert.Equal(roomId, updateMsg.RoomId)
		if assert.Len(updateMsg.Users, 1) {
			assert.EqualValues(sessionId, updateMsg.Users[0]["sessionId"])
			assert.Equal(true, updateMsg.Users[0]["virtual"])
			assert.EqualValues((FlagInCall | FlagWithPhone), updateMsg.Users[0]["inCall"])
		}
	}

	msg3 := MustSucceed1(t, client.RunUntilMessage, ctx)
	if flagsMsg, ok := checkMessageParticipantFlags(t, msg3); ok {
		assert.Equal(roomId, flagsMsg.RoomId)
		assert.Equal(sessionId, flagsMsg.SessionId)
		assert.EqualValues(FLAG_MUTED_SPEAKING, flagsMsg.Flags)
	}

	// The virtual sessions are closed when the parent session is deleted.
	clientInternal.CloseWithBye()

	if msg2, ok := client.RunUntilMessage(ctx); ok {
		client.checkMessageRoomLeaveSession(msg2, sessionId)
	}
}
